<!-- viz -->
<script src="../js/d3.v4.min.js"></script>
<div id="dataviz"></div>
<style>
/* path.line {
  fill: none;
  stroke: #666;
  stroke-width: 2px;
} */

path.area {
  fill: #e7e7e7;
}

.axis {
  shape-rendering: crispEdges;
}

.x.axis line {
  stroke: #fff;
}

.x.axis .minor {
  stroke-opacity: .5;
}

.x.axis path {
  display: none;
}

.y.axis line, .y.axis path {
  fill: none;
  stroke: #000;
}
.guideline {
  margin-right: 100px;
  float: right;
}
.tooltip {	
  position: absolute;			
  text-align: center;
  height: 28px;					
  padding: 4px 7px;				
  font: 12px sans-serif;		
  background: lightsteelblue;	
  border: 0px;		
  border-radius: 8px;			
  pointer-events: none;			
}
</style>

<script>
var margin = {top: 80, right: 80, bottom: 80, left: 80},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

// Scales and axes. Note the inverted domain for the y-scale: bigger is up!
var x = d3.scaleTime().range([0, width]),
    y = d3.scaleLinear().range([height, 0]);

// An area generator, for the light fill.
var area = d3.area()
    .x(d => x(d.date))
    .y0(height)
    .y1(d => y(d.efficency));

// A line generator, for the dark stroke.
var line = d3.line().defined(function(d) { return d.efficency != 0; }) //.curve(d3.curveBasis)
    .x(d => x(d.date))
    .y(d => y(d.efficency));

d3.csv("history_photovoltaics.csv", type, function(error, data) {

  // Filter to one symbol; the S&P 500.
  var Si = data.filter(d => d.symbol == "Si");
  var CdTe = data.filter(d => d.symbol == "CdTe");
  var ibm = data.filter(d => d.symbol == 'IBM');

  // Compute the minimum and maximum date, and the maximum efficency.
  x.domain([parse("1974-Jan"), parse('2020-Jan')]);
  y.domain([0, d3.max(Si, function(d) { return d.efficency; })]).nice();

  // Add an SVG element with the desired dimensions and margin.
  var svg = d3.select("#dataviz").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

  // Add the x-axis.
  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + (height+10) + ")")
      .call(d3.axisBottom(x));

  // Add the y-axis.
  svg.append("g")
      .attr("class", "y axis")
      .attr("transform", "translate(" + -1 + ",0)")
      .call(d3.axisLeft(y));


  svg.selectAll('.line').data([Si]).enter()
      .append('path')
      .attr('class', 'line')
      .style('stroke','#69b3a2')
      .attr("stroke-width", 4)
      .attr("fill",'none')
      .attr('d', line)
      .call(transition);

  svg.selectAll("dot") //.delay('7000')
      .data(Si)
      .enter().append("circle")
      .attr("r", 8)
      .attr("cx", d => x(d.date))
      .attr("cy", d => y(d.efficency))
      .attr("stroke", "#69b3a2")
      .attr("stroke-width", 3)
      .attr("fill", "white")
      .on("mouseover", mouseover)
      .on("mousemove", mousemove)
      .on("mouseleave", mouseleave)
      

  svg.selectAll('.line2').data([CdTe]).enter()
      .append('path')
      .attr('class', 'line')
      .style('stroke','red')
      .attr("stroke-width", 4)
      .attr("fill",'none')
      .attr('d', line)
      .call(transition);

  svg.selectAll("dot2")
      .data(CdTe.filter(function(d) { return d.efficency != 0;; }))
      .enter().append("circle")
      .attr("r", 8)
      .attr("cx", d => x(d.date))
      .attr("cy", d => y(d.efficency))
      .attr("stroke", "red")
      .attr("stroke-width", 3)
      .attr("fill", "white")
      .on("mouseover", mouseover)
      .on("mousemove", mousemove)
      .on("mouseleave", mouseleave);


  /* Add 'curtain' rectangle to hide entire graph */
  // var curtain = svg.append('rect')
  //   .attr('x', (-1 * width-5))
  //   .attr('y', -1 * height)
  //   .attr('height', height)
  //   .attr('width', (width+5))
  //   .attr('class', 'curtain')
  //   .attr('transform', 'rotate(180)')
  //   .style('fill', '#ffffff')


  /* Create a shared transition for anything we're animating */
  // var t = svg.transition()
  //             .delay(750)
  //             .duration(10000)
  //             .ease(d3.easeLinear);

  // t.select('rect.curtain')
  //     .attr('width', 0);
});

// helper functions
var parse = d3.timeParse("%Y-%b") 
var format =d3.timeFormat("%b-%Y")

// Parse dates and numbers. We assume Si are sorted by date.
function type(d) {
  d.date = parse(d.date);
  d.efficency = +d.efficency;
  return d;
}
// create a tooltip
var Tooltip = d3.select("#dataviz")
  .append("div")
  .style("opacity", 0)
  .attr("class", "tooltip")

// Three function that change the tooltip when user hover / move / leave a cell
var mouseover = function(d) {
  Tooltip
  .style("opacity", 1)
}

var mousemove = function(d) {
  Tooltip
  .html("("+ format(d.date) +", " + d.efficency+")")
  .style("left", (d3.mouse(this)[0]+50) + "px")
  .style("top", (d3.mouse(this)[1]+20) + "px")
}

var mouseleave = function(d) {
    Tooltip.style("opacity", 0)
}

// tween functions
function transition(path) {
  path.transition()
      .duration(10000)
      .attrTween("stroke-dasharray", tweenDash);
}
function tweenDash() {
  var l = this.getTotalLength(),
      i = d3.interpolateString("0," + l, l + "," + l);
  return function (t) { return i(t); };
}
</script>